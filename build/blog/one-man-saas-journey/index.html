<!doctype html><html lang="en"><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1" name="viewport"><meta content="Discover why I &#39;over-engineered&#39; my latest SaaS, saving my time and headaches in the future." name="description"><meta content="William Cooke" name="author"><meta content="Why I Over-Engineered My MVP (And You Should Too) - William Cooke" property="og:title"><meta content="Discover why I &#39;over-engineered&#39; my latest SaaS, saving my time and headaches in the future." property="og:description"><meta content="article" property="og:type"><title>Why I Over-Engineered My MVP (And You Should Too) - William Cooke</title><style>:root{--bg:#121212;--fg:#e0e0e0;--secondary:#a0a0a0;--accent:#bb86fc;--muted:#707070;--code-bg:#1a1a1a;--border:rgba(224, 224, 224, 0.15)}*{margin:0;padding:0;box-sizing:border-box}body{font-family:'Fira Code','JetBrains Mono','SF Mono',monospace;background:var(--bg);color:var(--fg);line-height:1.6;min-height:100vh}.container{max-width:700px;margin:0 auto;padding:2rem}.back-nav{margin-bottom:2rem}.back-nav a{color:var(--secondary);text-decoration:none;font-size:.9rem;transition:color .2s}.back-nav a:hover{color:var(--accent)}.back-nav a::before{content:'← '}.article-header{margin-bottom:3rem;border-bottom:1px solid var(--border);padding-bottom:2rem}.article-meta{display:flex;gap:1rem;align-items:center;font-size:.8rem;color:var(--muted);margin-bottom:1rem}.tag{background:rgba(187,134,252,.1);color:var(--accent);padding:.2rem .5rem;border:1px solid rgba(187,134,252,.2);font-size:.7rem}h1{font-size:clamp(1.8rem, 5vw, 2.5rem);font-weight:400;text-transform:lowercase;margin-bottom:1rem;position:relative}h1::after{content:'_';animation:1.5s infinite cursor;color:var(--accent)}@keyframes cursor{0%,50%{opacity:1}100%,51%{opacity:0}}.lead{font-size:1.1rem;color:var(--secondary);margin-bottom:1.5rem;font-style:italic}.article-content h2{font-size:1.4rem;margin:2rem 0 1rem;color:var(--fg);text-transform:lowercase}.article-content h3{font-size:1.2rem;margin:1.5rem 0 .75rem;color:var(--secondary)}.article-content p{margin-bottom:1.5rem;color:var(--fg)}.article-content ol,.article-content ul{margin:1rem 0 1.5rem 1.5rem}.article-content li{margin-bottom:.5rem}.article-content blockquote{border-left:3px solid var(--accent);padding-left:1rem;margin:1.5rem 0;color:var(--secondary);font-style:italic}.article-content code{background:var(--code-bg);padding:.2rem .4rem;border:1px solid var(--border);font-size:.9rem;color:var(--accent)}.article-content pre{background:var(--code-bg);border:1px solid var(--border);border-left:3px solid var(--accent);padding:1rem;margin:1.5rem 0;overflow-x:auto;font-size:.85rem}.article-content pre code{background:0 0;border:none;padding:0;color:var(--fg)}.article-footer{margin-top:3rem;padding-top:2rem;border-top:1px solid var(--border);text-align:center}.footer-nav{display:flex;gap:1rem;justify-content:center;flex-wrap:wrap}.footer-nav a{color:var(--secondary);text-decoration:none;padding:.5rem 1rem;border:1px solid var(--border);transition:.2s}.footer-nav a:hover{color:var(--accent);border-color:var(--accent)}.footer-nav a::before{content:'[ ';color:var(--muted)}.footer-nav a::after{content:' ]';color:var(--muted)}.footer-nav a:hover::after,.footer-nav a:hover::before{color:var(--accent)}@media (max-width:480px){.container{padding:1rem}.article-meta{flex-direction:column;align-items:flex-start;gap:.5rem}.footer-nav{flex-direction:column}}@media (prefers-reduced-motion:reduce){h1::after{animation:none}}</style><div class="container"><nav class="back-nav"><a href="#" onclick="returnToBlog(); return false;">back</a></nav><header class="article-header"><div class="article-meta"><span class="date">2025-08-15</span> <span class="read-time">4 min read</span><div class="tags"><span class="tag">performance</span><span class="tag">optimisation</span><span class="tag">saas</span><span class="tag">elixir</span></div></div><h1>Why I Over-Engineered My MVP (And You Should Too)</h1><p class="lead">Using the right tools and a little forethought is a compounding reward</header><article class="article-content"><p>Building my waitlist SaaS solo, I had an unfair advantage: I&#39;d already lived through the pain of retrofitting half-baked features into production systems. Having spent years fixing other people&#39;s &quot;we&#39;ll think about that later&quot; decisions, I knew exactly which corners not to cut.<p>This is how I built Clamber with the boring bits done properly and still shipped fast and lean.<h2>The Audit Trail Nobody Wants to Build</h2><p>Something that keeps me up at night as a solo developer is my responsibility for customer data. I&#39;ve seen too many codebases with authentication bolted on as an afterthought, user actions vanishing into the void, and zero ability to investigate when something goes wrong.<p><strong>So this time:</strong> I built comprehensive security auditing from day one. Every OAuth login, every failed password attempt, gets tracked with a security context module. Not because it&#39;s exciting to implement, but because &quot;we have no logs&quot; isn&#39;t something you want to tell customers after a breach.<p>When someone asks about our security practices, I can truthfully say, I have security logging and compliance concerns at heart.<h2>Performance Monitoring: More Than &quot;It Works on My Machine&quot;</h2><p>I work with software that has zero visibility into its own health every day. It makes refactoring a gamble, debugging a nightmare, and performance work something everyone avoids. I wanted to know—really know—how my system performed in production.<p><strong>So this time:</strong> I built on the basic telemetry of Phoenix. API response times, cache hit rates, database query performance. Real numbers, not guesses. I cache a lot of api context for great performance from day one. It saves on cloud bills.<p>When prospects ask &quot;What&#39;s your uptime?&quot; I don&#39;t hand-wave. I show them the status page. When something&#39;s slow, I know exactly where and why. It turns out users appreciate transparency about performance as much as the performance itself.<h2>Documentation as a Feature, Not an Afterthought</h2><p>As a solo developer, I&#39;m also the entire support team. And honestly? I&#39;m rubbish at support as I&#39;m too busy building. But I want users to succeed with my product without needing to chase me down.<p><strong>So this time:</strong> I treated documentation like a core feature. Empty states show contextual getting-started guides. API examples use the customer&#39;s actual API key and domain. Error messages explain what went wrong <em>and how to fix it</em>.<p>I wrote docs by walking through my own user journey, repeatedly. And I am still refining them! Every confusion I hit became a clarification in the docs. Every setup step I might forget got documented.<p>The result? Documentation became a sales tool. Prospects can evaluate the entire integration before signing up. Customers can onboard themselves. It&#39;s the compound interest of good documentation, every hour spent writing saves ten hours of support.<h2>Choosing Tools That Scale</h2><p>Here&#39;s where I admit this whole article is really about why Phoenix and Elixir changed everything for me. The framework is opinionated in exactly the right ways. LiveView makes real-time features trivial. ETS gives you caching that just works. The BEAM gives you fault tolerance and concurrency that would cost a fortune to build in most stacks.<p>Building these &quot;enterprise&quot; features wasn&#39;t a months-long slog—it was a few days of enjoyable work. Rate limiting? There&#39;s a pattern for that. Background jobs? GenServers have you covered. Need to handle a million users? Same deployment, just bigger servers.<p>The crucial insight isn&#39;t which features to build—it&#39;s choosing tools that make the right features easy.<h2>The Maths of Building It Right</h2><p>Building audit logging into an empty codebase: one day.<br>Retrofitting it into a live system: months of careful migration.<p>Adding rate limiting with no traffic: an afternoon.<br>Adding it during a DDoS: panic, downtime, and apologies.<p>Designing for multi-tenancy with zero customers: slightly abstract but straightforward.<br>Reshaping single-tenant data later: migration scripts, edge cases, and prayer.<p>The pattern is clear: early implementation is measured in days, later retrofitting in months—if you survive it.<h2>What This Really Means for Solo Developers</h2><p>If you&#39;re building your first SaaS, you can&#39;t afford to learn these lessons the hard way. But you can steal from those who have:<p><strong>Build security properly from the start.</strong> Not because you&#39;ll get hacked tomorrow, but because &quot;move fast and break things&quot; shouldn&#39;t include breaking trust.<p><strong>Make your system observable.</strong> You can&#39;t fix what you can&#39;t measure, and you can&#39;t improve what you don&#39;t understand.<p><strong>Document as you build.</strong> Future you is your most important user, and current you is the only one who knows how it actually works.<p><strong>Choose enjoyable, powerful tools.</strong> The exciting part should be your product, not wrestling with your stack.<p>The counterintuitive truth: building these &quot;enterprise&quot; features early makes solo development easier, not harder. You&#39;re not over-engineering; you&#39;re front-loading the complexity you&#39;d face anyway, when it&#39;s still simple to implement.<p>Will I ever need audit logs for millions of users? Probably not. But I sleep better knowing they&#39;re there. And more importantly, I build faster knowing I won&#39;t have to retrofit them later.<p>I&#39;ve spent time fixing other&#39;s shortcuts. For myself, I chose a different kind of complexity: the kind that makes tomorrow&#39;s problems easier to solve, not today&#39;s problems harder to find.<p>I built the SaaS I&#39;d be happy to inherit!</article><footer class="article-footer"><nav class="footer-nav"><a href="/">home</a></nav></footer></div><script>function isBackFromSameDomain(){const o=document.referrer,n=window.location.hostname;return!!o&&new URL(o).hostname===n}const toHome=()=>window.location.href="/",returnToBlog=()=>isBackFromSameDomain()?history.back():toHome();</script>